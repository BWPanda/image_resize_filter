<?php
// $Id$

/**
 * @file image_resize_fitler.module
 *
 * After adding to an input format, this filter will parse the contents of
 * submitted content and automatically scale image files to match the set
 * dimensions of img tags.
 *
 * Image that have been created take on the ownership of the original file.
 * Making so when the primary node is deleted, the images it provided are
 * deleted also.
 *
 */

/**
 * Implementation of hook_filter().
 */
function image_resize_filter_filter($op, $delta = 0, $format = -1, $text = '', $cache_id = 0) {
  static $images = array();

  switch ($op) {
    case 'list':
      return array(0 => t('Image resize filter'));

    case 'description':
      return t('Resizes images to the exact dimensions specified in the &lt;img&gt; tag.');

    case 'settings':
      return image_resize_filter_form($format);

    case 'prepare':
      // Get a list of images in this text *before* other filters are run.
      // This makes is so that we can get the height and width within style
      // properties before they are stripped out by the Filtered HTML filter.
      $settings['allowed_difference'] = variable_get('image_resize_filter_allowed_difference_'. $format, 20);
      $settings['image_locations'] = variable_get('image_resize_filter_image_locations_'. $format, array('local'));
      $images[$cache_id] = image_resize_filter_get_images($settings, $text);
      return $text;

    case 'process':
      return isset($images[$cache_id]) ? image_resize_filter_process($images[$cache_id], $text) : $text;

    default:
      return $text;
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function image_resize_filter_nodeapi(&$node, $op, $teaser, $page) {
  if (($op == 'presave' || $op == 'delete') && isset($node->files)) {
    // Delete upload.module derivatives.
    foreach ($node->files as $fid => $file) {
      // File is an an object on delete, but array on presave.
      $file = (array)$file;
      if ($file['remove'] || $op == 'delete') {
        image_resize_filter_remove_derivatives($file['filepath']);
      }
    }
    // TODO: Add imagefield/filefield support.
  }
}

function image_resize_filter_form($format) {
  $form = array();

  $form['image_resize'] = array(
    '#type' => 'fieldset',
    '#title' => t('Image resize settings'),
    '#collapsible' => TRUE,
    '#description' => t('The image resize filter will analyze &lt;img&gt; tags and compare the given height and width attributes to the actual file. If the file dimensions are different than those given in the &lt;img&gt; tag, the image will be copied and the src attribute will be updated to point to the resized image.'),
  );

  $form['image_resize']['image_resize_filter_allowed_difference_'. $format] = array(
    '#type' => 'textfield',
    '#title' => t('Allowed image size difference'),
    '#default_value' => variable_get('image_resize_filter_allowed_difference_'. $format, 20),
    '#size' => 5,
    '#maxlength' => 3,
    '#field_suffix' => ' '. t('pixels'),
    '#required' => TRUE,
    '#description' => t('The number of pixels the &lt;img&gt; tag and actual image are allowed to differ before creating a resized version of the image. Set to 0 to always match &lt;img&gt; tags exactly.'),
  );

  $form['image_resize']['image_resize_filter_image_locations_'. $format] = array(
    '#type' => 'checkboxes',
    '#title' => t('Resize images stored'),
    '#options' => array('local' => t('Locally'), 'remote' => t('On remote servers')),
    '#default_value' => variable_get('image_resize_filter_image_locations_'. $format, array('local')),
    '#required' => TRUE,
    '#description' => t('This option will determine which images will be analyzed for &lt;img&gt; tag differences. Enabling resizing of remote images can have performance impacts, as all images in the filtered text needs to be transfered via HTTP each time the filter cache is cleared.'),
  );

  return $form;
}

/**
 * Parsing function to locate all images in a piece of text that need replacing.
 *
 * @param $settings
 *   An array of settings that will be used to identify which images need
 *   updating. Includes the following:
 *
 *   - allowed_difference: A maximum difference between the img tag's height
 *     and width properties versus the actual size of the image. Can be used
 *     to prevent resizing of images when the tag is only a few pixels off.
 *
 *   - image_locations: An array of acceptable image locations. May contain any
 *     of the following values: "remote". Remote image will be downloaded and
 *     saved locally. This procedure is intensive as the images need to
 *     be retrieved to have their dimensions checked.
 *
 * @param $text
 *   The text to be updated with the new img src tags.
 */
function image_resize_filter_get_images($settings, $text) {
  $images = array();

  // Find all image tags, ensuring that they have a src.
  $matches = array();
  preg_match_all('/<img[^>]*?src[ ]*=[ ]*"([^"]+)"[^>]*>/', $text, $matches);

  // Loop through matches and find if replacements are necessary.
  // $matches[0]: All complete image tag matches.
  // $matches[1]: The src value of each match.
  foreach ($matches[0] as $key => $img_tag) {
    $src = $matches[1][$key];

    $width = NULL;
    $height = NULL;
    $needs_height = FALSE;
    $needs_width = FALSE;

    // Because we don't know the order of the attributes and images might not
    // have both attributes, match individually for height and width.
    foreach (array('width', 'height') as $property) {
      $matches = array();
      preg_match_all('/'. $property .'[ ]*([=:])[ ]*"?([0-9]+)"?/', $img_tag, $matches);
      // In the odd scenario there is both a style="width: xx" and a width="xx"
      // tag, base our calculations off the style tag, since that's what the
      // browser will display.
      $key = 0;
      $needs_property = FALSE;
      if (count($matches[1]) > 1) {
        $key = array_search(':', $matches[1]);
      }
      // Only a style property found, we'll need to add a real height/width tag
      // to the HTML later. This specifically prevents problems with FCKeditor
      // that only adds style tags when resizing images.
      elseif ($matches[1][$key] == ':'){
        $needs_property = TRUE;
      }
      ${$property} = !empty($matches[2][$key]) ? $matches[2][$key] : FALSE;
      ${'needs_'. $property} = $needs_property;
    }

    // If height and width are both missing, nothing to do here.
    if (!$width && !$height) {
      continue;
    }

    // Check the image extension.
    $extension_matches = array();
    preg_match('/.([a-zA-Z0-9]+)$/', $src, $extension_matches);
    if (empty($extension_matches) || !in_array(drupal_strtolower($extension_matches[1]), array('png', 'jpg', 'jpeg', 'gif'))) {
      continue;
    }
    $extension = strtolower($extension_matches[1]);

    // Determine if this is a local or remote file.
    $location = 'unknown';
    if (strpos($src, '/') === 0 || strpos($src, '.') === 0) {
      $location = 'local';
    }
    elseif (preg_match('/http[s]?:\/\/'. preg_quote($_SERVER['HTTP_HOST'], '/') .'/', $src)) {
      $location = 'local';
    }
    elseif (strpos($src, 'http') === 0) {
      $location = 'remote';
    }

    // If not resizing images in this location, continue on to the next image.
    if (!in_array($location, $settings['image_locations'])) {
      continue;
    }

    // Convert the URL to a local path.
    $local_path = NULL;
    if ($location == 'local') {
      if (strpos($src, '.') !== 0) {
        // TODO: Support private downloads by matching system/files here.
        $local_path = preg_replace('/(http[s]?:\/\/'. preg_quote($_SERVER['HTTP_HOST'], '/') .')?'. preg_quote(base_path(), '/') .'/', '', $src, 1);
      }
      $local_path = urldecode($local_path);
    }

    // Get the image size.
    if ($location == 'local') {
      $image_size = getimagesize($local_path);
    }
    else {
      $image_size = getimagesize($src);
    }

    // All this work and the image isn't even there. Bummer. Next image please.
    if ($image_size == FALSE) {
      continue;
    }

    $actual_width = $image_size[0];
    $actual_height = $image_size[1];

    // If either height or width is missing, calculate the other.
    if (!$height) {
      $ratio = $actual_height/$actual_width;
      $height = round($ratio * $width);
    }
    elseif (!$width) {
      $ratio = $actual_width/$actual_height;
      $width = round($ratio * $height);
    }

    // Finally, if width and heights match up, don't do anything.
    if ($actual_width == $width && $actual_height == $height) {
      continue;
    }

    // If getting this far, the image exists and is not the right size.
    // Add all information to a list of images that need resizing.
    $images[] = array(
      'expected_size' => array('width' => $width, 'height' => $height),
      'actual_size' => array('width' => $image_size[0], 'height' => $image_size[1]),
      'add_properties' => array('width' => $needs_width, 'height' => $needs_height),
      'original' => $src,
      'location' => $location,
      'local_path' => $local_path,
      'mime' => $image_size['mime'],
      'extension' => $extension,
    );
  }

  return $images;
}


/**
 * Processing function for image resize filter. Replace img src properties
 * with a URL to a resized image.
 *
 * @param $images
 *   An array of image information, detailing images that need to be replaced.
 * @param $text
 *   The original text of the post that needs src tags updated.
 */
function image_resize_filter_process($images, $text) {
  foreach ($images as $image) {
    // Copy remote images locally.
    if ($image['location'] == 'remote') {
      $result = drupal_http_request($image['original']);
      if ($result->code == 200) {
        $tmp_file = tempnam(file_directory_temp(), 'image_resize_filter_');
        $path_info = pathinfo($image['original']);

        $handle = fopen($tmp_file, 'w');
        fwrite($handle, $result->data);
        fclose($handle);
        $image['local_path'] = $tmp_file;
        $image['destination'] = file_directory_path() .'/resize/remote/'. md5($result->data) .'-'. $image['expected_size']['width'] .'x'. $image['expected_size']['height'] .'.'. $path_info['extension'];
      }
      else {
        continue;
      }
    }
    else {
      $path_info = pathinfo($image['local_path']);
      $local_file_dir = str_replace(file_directory_path(), '', $path_info['dirname']);
      $local_file_dir = !empty($local_file_dir) ? $local_file_dir . '/' : '';
      $image['destination'] = file_directory_path() .'/resize/'. $local_file_dir . $path_info['filename'] .'-'. $image['expected_size']['width'] .'x'. $image['expected_size']['height'] .'.'. $path_info['extension'];
    }

    // Ensure that the destination directories exist.
    $directory = dirname($image['destination']);
    $folders = explode('/', $directory);
    $current_directory = '';
    foreach ($folders as $folder) {
      $current_directory .= $folder .'/';
      $check_directory = $current_directory;
      file_check_directory($check_directory, FILE_CREATE_DIRECTORY);
    }

    // Resize the local image.
    if (!file_exists($image['destination'])) {
      image_resize($image['local_path'], $image['destination'], $image['expected_size']['width'], $image['expected_size']['height']);
    }

    // Replace the existing image source with the resized image.
    $base_path = base_path();
    // Set the image we're currently updating in the callback function.
    image_resize_fitler_update_tag(NULL, $image);
    $text = preg_replace_callback('/(<img[^>]*?src[ ]*=[ ]*")'. preg_quote($image['original'] ,'/') .'("[^>]*?)(\/?>)/', 'image_resize_fitler_update_tag', $text);
  }
  return $text;
}

/**
 * Regular expression callback.
 *
 * @param $matches
 *   The matches for a call to preg_replace_callback().
 * @param $new_image
 *   If passed in, this will set a static variable so that this image data is
 *   available when this function is called from a regular expression.
 */
function image_resize_fitler_update_tag($matches = NULL, $new_image = NULL) {
  static $image;

  $image = isset($new_image) ? $new_image : $image;

  $output = '';
  $output .= $matches[1]; // The start of the tag.
  $output .= base_path() . $image['destination']; // The new src.
  $output .= $matches[2]; // The end of the tag, excluding the closing "/>".

  // Add height and width properties if they are missing from the original tag.
  $output .= $image['add_properties']['width'] ? ' width="'. $image['expected_size']['width'] .'"' : '';
  $output .= $image['add_properties']['height'] ? ' height="'. $image['expected_size']['height'] .'"' : '';

  $output .= $matches[3]; // The closing "/>".

  return $output;
}

/**
 * Delete all generated image when the original file is removed.
 */
function image_resize_filter_remove_derivatives($original_filepath) {

  // First delete all derivatives in the saved file location.
  $path_info = pathinfo($original_filepath);
  $basename = $path_info['basenname'];
  $extension = $path_info['extension'];
  $file_directory_path = file_directory_path();
  $directory = $file_directory_path .'/resize/'. $path_info['dirname'];

  // Delete all the derivatives.
  file_scan_directory($directory, quotemeta($basename) .'-[0-9]+[x][0-9]+\.'. quotemeta($extension), array('.', '..', 'CVS'), 'file_delete');

  // Then work up the directories and delete any empty ones.
  $folders = explode('/', $directory);
  $directories = array();
  $current_directory = '';
  foreach ($folders as $folder) {
    $current_directory .= $folder .'/';
    $directories[] = $current_directory;
  }

  foreach (array_reverse($directories) as $directory) {
    if ($directory == ($file_directory_path .'/')) {
      break;
    }

    $directory_files = file_scan_directory($directory, '.*');
    if (empty($directory_files)) {
      @rmdir($directory);
    }
    else {
      break;
    }
  }
}